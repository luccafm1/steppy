/* autogenerated by Processing revision 1292 on 2023-05-16 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import processing.sound.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class lgbt_engine extends PApplet {

// LGBT Engine
 
boolean jogoiniciado = false ; 
boolean fase1 = false ;
boolean fase2 = false ;
// booleana para o menu 
int faseSelecionada = 0;

SoundFile ambiente;

PImage gaias,gabriel,luca,chao,parede,teto;

float anguloY,anguloG;

float centroX,centroY,centroZ;

PVector playerPos,inimigoPos;
float inimigoVel,playerVel;

public void setup(){
  background(0,0,0);
  /* size commented out by preprocessor */;
  
  // carregar imagens 
  gaias = loadImage("gaias.jpg");
  gabriel = loadImage("gabriel.jpg");
  chao = loadImage("carpet.jpg");
  teto = loadImage("roof.jpg");
  parede = loadImage("wall.jpg");
  
  //vetores camera
  playerPos = new PVector(0,0,1200);
  playerVel = 30;
  inimigoPos = new PVector(0,0,1200);
  inimigoVel = 15;
  // som 
  ambiente = new SoundFile(this,"ambiente.mp3"); 
  ambiente.play();
  ambiente.play();
  ambiente.loop();
}

int xp = width/2;
int yp = height/2;

public void draw(){ 
  //iniciando jogo base
  if (jogoiniciado) {
  background(0);
  fill(50);
 // Calcule a distância entre o jogador e o inimigo
  float distance = sqrt(pow(inimigoPos.x - playerPos.x, 2) + pow(inimigoPos.y - playerPos.y, 2) + pow(inimigoPos.z - playerPos.z, 2));
  
  // Aumente o volume do áudio se a distância for menor ou igual à distância máxima
  if (distance <= 10.0f) {
    ambiente.amp(0.5f);
  }
  //shaders
  lights();

  pushMatrix();
  //inimigos
  noLights();
  translate(500,0,500); 
  if (fase1) {
    inimigo(gabriel); 
  } 
  else if (fase2) { 
    inimigo(gaias); 
  }
  lights();
  noStroke();
  //orientacao
  fill(255,0,0);
  popMatrix();

  movimentoCamera();
  
  fill(255,255,255);
  
  float x = 50; // constante basica
  float y = 20; // constante basica
  
  //chao e teto do jogo
  textureWrap(REPEAT);
  PVector[] verticesChao = new PVector[4];
  for (int i = 0; i < 5000; i += 2500) { 
    verticesChao[0] = new PVector(0, 0, 0);
    verticesChao[1] = new PVector(i*x, 0, 0);
    verticesChao[2] = new PVector(i*x, i*x, 0);
    verticesChao[3] = new PVector(0, i*x, 0);
    face(verticesChao[0],verticesChao[1],verticesChao[2],verticesChao[3],chao,50000,50000);

    verticesChao[0] = new PVector(0, 0, 2000);
    verticesChao[1] = new PVector(i*x, 0, 2000);
    verticesChao[2] = new PVector(i*x, i*y, 2000);
    verticesChao[3] = new PVector(0, i*y, 2000);
    face(verticesChao[0],verticesChao[1],verticesChao[2],verticesChao[3],teto,50000,50000);
  }
  //parede do jogo
  textureWrap(REPEAT);
  PVector[] verticesParede = new PVector[4];
  for (int i = 0; i < 200; i += 100) { 
    verticesParede[0] = new PVector(0, 0, 0);
    verticesParede[1] = new PVector(i*200, 0, 0);
    verticesParede[2] = new PVector(i*200, 0, i*y);
    verticesParede[3] = new PVector(0, 0, i*y);
    
    // bloco
    
    float posX = 1000;
    float posY = 1000;

    //face esquerda
    verticesParede[0] = new PVector(0, 2*posY, 0);
    verticesParede[1] = new PVector(i*x, 2*posY, 0);
    verticesParede[2] = new PVector(i*x, 2*posY, i*y);
    verticesParede[3] = new PVector(0, 2*posY, i*y);
    face(verticesParede[0],verticesParede[1],verticesParede[2],verticesParede[3],parede,1300,964);
    //face direita
    verticesParede[0] = new PVector(0, posY*4, 0);
    verticesParede[1] = new PVector(i*x, posY*4, 0);
    verticesParede[2] = new PVector(i*x, posY*4, i*y);
    verticesParede[3] = new PVector(0, posY*4, i*y);
    face(verticesParede[0],verticesParede[1],verticesParede[2],verticesParede[3],parede,1300,964);
    //face frontal
    verticesParede[0] = new PVector(5*posX, 2*posY, 0);
    verticesParede[1] = new PVector(5*posX, 2*posY+i*y, 0);
    verticesParede[2] = new PVector(5*posX, 2*posY+i*y, i*y);
    verticesParede[3] = new PVector(5*posX, 2*posY, i*y);
    face(verticesParede[0],verticesParede[1],verticesParede[2],verticesParede[3],parede,1300,964);
    //face anterior
    verticesParede[0] = new PVector(0, 2*posY, 0);
    verticesParede[1] = new PVector(0, 2*posY+i*y, 0);
    verticesParede[2] = new PVector(0, 2*posY+i*y, i*y);
    verticesParede[3] = new PVector(0, 2*posY, i*y);
    face(verticesParede[0],verticesParede[1],verticesParede[2],verticesParede[3],parede,1300,964);
    circle(verticesParede[0].x, verticesParede[0].y, 100);
    circle(verticesParede[1].x, verticesParede[1].y, 100);
    if (colisao(verticesParede[0],verticesParede[1]) == true){
        playerVel *= -10;
      }
      else {
        playerVel = 30;
      }
  }


  if (keyPressed) {
    if (keyCode == LEFT || key == 'a' || key == 'A') {
      PVector direcao = new PVector(-centroY,centroX,0);
      direcao.normalize();
      direcao.mult(playerVel);
      playerPos.sub(direcao);
    }
    if (keyCode == RIGHT || key == 'd' || key == 'D') {
      PVector direcao = new PVector(-centroY,centroX,0);
      direcao.normalize();
      direcao.mult(playerVel);
      playerPos.add(direcao);
    }
    if (keyCode == UP || key == 'w' || key == 'W') {
      PVector direcao = new PVector(centroX,centroY,0);
      direcao.normalize();
      direcao.mult(playerVel);
      playerPos.add(direcao);
    }
    if (keyCode == DOWN || key == 's' || key == 'S') {
      PVector direcao = new PVector(centroX,centroY,0);
      direcao.normalize();
      direcao.mult(playerVel);
      playerPos.sub(direcao);
    }
    // MODO FLIGHT (debug)
    if (keyCode == CONTROL) {
      playerPos.z -= playerVel;
    }
    if (keyCode == SHIFT) {
      playerPos.z += playerVel;
    }
  } 
 } 
   else {
 textSize(32);
  textAlign(CENTER);
  text("Nome do jogo", width/2, 150);
  
  // Desenhar as opções de fase
  textSize(24);
  text("Fase 1", width/2, 350);
  text("Fase 2", width/2, 450);
   }
}
// face com textura (avançado)
public void face(PVector v1, PVector v2, PVector v3, PVector v4, PImage img, int u, int v) {
  beginShape(QUADS);
  texture(img);
  vertex(v1.x, v1.y, v1.z, 0, 0);
  vertex(v2.x, v2.y, v2.z, u, 0);
  vertex(v3.x, v3.y, v3.z, u, v);
  vertex(v4.x, v4.y, v4.z, 0, v);
  endShape();
}
// face sem textura (simples)
public void face(PVector v1, PVector v2, PVector v3, PVector v4) {
  beginShape(QUADS);
  vertex(v1.x, v1.y, v1.z);
  vertex(v2.x, v2.y, v2.z);
  vertex(v3.x, v3.y, v3.z);
  vertex(v4.x, v4.y, v4.z);
  endShape();
}

public void movimentoCamera(){ 
  //angulo rotacao (X)
  anguloG = map(mouseX, 0, width, 0, TWO_PI);
  //angulo rotacao (Y)
  anguloY = map(mouseY, 0, height, 0, PI);
  centroX = cos(anguloG) * sin(anguloY);
  centroY = sin(anguloG) * sin(anguloY);
  centroZ = cos(anguloY);
  
  PVector dir = new PVector(centroX,centroY,centroZ);
  dir.normalize();
  translate(playerPos.x,playerPos.y,playerPos.z);
  camera(playerPos.x, playerPos.y, playerPos.z, playerPos.x + dir.x, playerPos.y + dir.y, playerPos.z + dir.z, 0, 0, -1);
}

public void inimigo(PImage img){
  pushMatrix();
  //seguir player
  PVector disPos = PVector.sub(playerPos,inimigoPos);
  disPos.normalize();
  inimigoPos.add(disPos.mult(inimigoVel));
  translate(inimigoPos.x,inimigoPos.y,inimigoPos.z);
  //diferença entre vetores x,y de player e inimigo
  PVector dir = PVector.sub(new PVector(playerPos.x, playerPos.y, 0), new PVector(inimigoPos.x, inimigoPos.y, 0));
  dir.normalize();
  //rotacionar inimigo
  float apontar = atan2(dir.y,dir.x);
  rotateX(radians(90));
  rotateZ(radians(180));
  rotateY(radians(90));
  rotateY(-apontar);
  rotateZ(radians(180));
  rotateX(radians(90));
  //inimigo
  PVector[] verticesInimigo = new PVector[4];
  verticesInimigo[0] = new PVector(0, 0, 0);
  verticesInimigo[1] = new PVector(2000, 0, 0);
  verticesInimigo[2] = new PVector(2000, 0, 2000);
  verticesInimigo[3] = new PVector(0, 0, 2000);
  face(verticesInimigo[0],verticesInimigo[1],verticesInimigo[2],verticesInimigo[3],img,1000,1000);
  popMatrix();
  
}

public boolean colisao(PVector x, PVector y){
  println(playerPos);
  println(x,y);
  if (playerPos.y > x.y && playerPos.x > x.x && playerPos.y < y.y && playerPos.x > y.x) {
      return true;
    }
    else {
      return false;
    }
}  
// ativação do play
public void mousePressed() {
  if (mousePressed && mouseX > 480 && mouseX < 880) {
    if (mouseY > 325 && mouseY < 375) {
      // Se o botão do mouse estiver pressionado sobre a opção "Fase 1", então selecionar a fase 1
      fase1 = true;
      jogoiniciado = true; 
       exit();
    } else if (mouseY > 425 && mouseY < 475) {
      // Se o botão do mouse estiver pressionado sobre a opção "Fase 2", então selecionar a fase 2
      fase2 = true; 
      jogoiniciado = true; 
       
    }
    
  }
 }


  public void settings() { size(1360, 900, P3D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "lgbt_engine" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
